<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bike Game with Ducks</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #484848;
        }

        #game-board {
            position: relative;
            width: 480px;
            height: 525px;
            background-color: #d6d6d6;
            border: 2px solid black;
        }

        .square {
            position: absolute;
            width: 40px;
            height: 40px;
        }

        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 45px;
            background-color: #484848;
            color: #d6d6d6;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 2px solid black;
        }

        .icon {
            position: absolute;
            width: 35px;
            height: 35px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-board">
        <div id="top-bar">Use W A S D to move</div>
    </div>

    <script>
        class BikeGame {
            constructor() {
                this.gameBoard = document.getElementById("game-board");
                this.numSquares = 12; // grid size
                this.squareSize = 40; // size of each square
                this.topBarHeight = 45; // height of the top bar
                this.duckIconSize = 35; // size of the icons
                this.squares = []; // grid squares
                this.ducks = []; // list of ducks on the grid
                this.player = { x: 5, y: 5, direction: "up", tail: [] }; // player data
                this.currentKey = null; // last pressed key
                this.score = 0; // player's score
                this.gameInterval = null; // game loop interval

                // load all images
                this.images = {
                    bike: {
                        right: this.loadImage("bikeRight.png"),
                        left: this.loadImage("bikeLeft.png"),
                        up: this.loadImage("bikeUp.png"),
                        down: this.loadImage("bikeDown.png"),
                    },
                    ducks: {
                        up: this.loadImage("duckUp.png"),
                        right: this.loadImage("duckRight.png"),
                        down: this.loadImage("duckDown.png"),
                        left: this.loadImage("duckLeft.png"),
                    },
                };

                this.init(); // start the game
            }

            loadImage(src) {
                const img = new Image();
                img.src = src; // set image source
                img.style.width = `${this.duckIconSize}px`;
                img.style.height = `${this.duckIconSize}px`;
                return img;
            }

            init() {
                this.createGrid(); // create the grid
                this.spawnDuck(); // add the first duck
                this.renderPlayer(); // display the player
                this.startGameLoop(); // start the game loop

                document.addEventListener("keydown", (e) => this.handleKeyPress(e)); // listen for key presses
            }

            createGrid() {
                for (let row = 0; row < this.numSquares; row++) {
                    this.squares[row] = [];
                    for (let col = 0; col < this.numSquares; col++) {
                        const square = document.createElement("div");
                        square.className = "square";
                        square.style.left = `${col * this.squareSize}px`;
                        square.style.top = `${row * this.squareSize + this.topBarHeight}px`;
                        square.style.backgroundColor =
                            (row % 2 === 0 && col % 2 === 0) || (row % 2 === 1 && col % 2 === 1)
                                ? "rgb(0, 128, 43)"
                                : "rgb(0, 179, 60)";
                        this.gameBoard.appendChild(square);
                        this.squares[row][col] = square;
                    }
                }
            }

            movePlayer() {
                const direction = this.currentKey;
                if (!direction) return;

                // Add the current head position to the tail
                //this.player.tail.unshift({ x: this.player.x, y: this.player.y, direction: this.player.direction });

                // Limit the tail length to match the score
                if (this.player.tail.length > this.score) {
                    this.player.tail.pop(); // Remove excess segments
                    const removedSegment = this.player.tail.pop(); // Remove the oldest segment
                    if (removedSegment.element) {
                        removedSegment.element.remove(); // Remove the corresponding DOM element
                    }
                }

                // Update player position based on the current direction
                if (direction === "w") {
                    this.player.y--;
                    this.player.direction = "up";
                } else if (direction === "a") {
                    this.player.x--;
                    this.player.direction = "left";
                } else if (direction === "s") {
                    this.player.y++;
                    this.player.direction = "down";
                } else if (direction === "d") {
                    this.player.x++;
                    this.player.direction = "right";
                }

                // Check for game over conditions
                this.checkGameOver();

                // Render the updated player and tail
                this.renderPlayer();
            }

            renderPlayer() {
                const playerImage = this.images.bike[this.player.direction];

                // Remove the previous player image
                if (this.player.element) {
                    this.player.element.remove();
                }

                // Render the new player image
                const playerElement = playerImage.cloneNode();
                playerElement.style.position = "absolute";
                playerElement.style.left = `${this.player.x * this.squareSize + (this.squareSize - this.duckIconSize) / 2}px`;
                playerElement.style.top = `${this.player.y * this.squareSize + this.topBarHeight + (this.squareSize - this.duckIconSize) / 2}px`;
                this.gameBoard.appendChild(playerElement);
                this.player.element = playerElement;
                
                // DEBUG: Log the player's position and tail length
                console.log("Player position:", this.player.x, this.player.y);
                console.log("Tail length:", this.player.tail.length);

                // Remove all existing tail elements from the DOM before re-rendering
                const existingTailElements = document.querySelectorAll(".tail-segment");
                existingTailElements.forEach((el) => el.remove());

                // Render the tail
                this.player.tail.forEach((segment, index) => {
                    const tailDirection = index === 0 ? this.player.direction : this.player.tail[index - 1].direction;
                    const tailImage = this.images.ducks[tailDirection];

                    // Remove the previous segment image
                    if (segment.element) {
                        segment.element.remove();
                        segment.element.style.left = `${segment.x * this.squareSize + (this.squareSize - this.duckIconSize) / 2}px`;
                        segment.element.style.top = `${segment.y * this.squareSize + this.topBarHeight + (this.squareSize - this.duckIconSize) / 2}px`;
 
                    }

                    // Render the new segment image
                    const tailElement = tailImage.cloneNode();
                    tailElement.style.position = "absolute";
                    tailElement.style.left = `${segment.x * this.squareSize + (this.squareSize - this.duckIconSize) / 2}px`;
                    tailElement.style.top = `${segment.y * this.squareSize + this.topBarHeight + (this.squareSize - this.duckIconSize) / 2}px`;
                    this.gameBoard.appendChild(tailElement);

                    // Assign the created element to the segment
                    segment.element = tailElement;
                });
            }

            spawnDuck() {
                let duck;
                do {
                    duck = { x: Math.floor(Math.random() * this.numSquares), y: Math.floor(Math.random() * this.numSquares), direction: "up" };
                } while (this.isOccupied(duck.x, duck.y)); // Ensure ducks do not spawn on the player or its tail

                const duckElement = this.images.ducks.right.cloneNode();
                duckElement.style.position = "absolute";
                duckElement.style.left = `${duck.x * this.squareSize + (this.squareSize - this.duckIconSize) / 2}px`;
                duckElement.style.top = `${duck.y * this.squareSize + this.topBarHeight + (this.squareSize - this.duckIconSize) / 2}px`;

                this.ducks.push({ ...duck, element: duckElement });
                this.gameBoard.appendChild(duckElement);
            }

            isOccupied(x, y) {
                if (this.player.x === x && this.player.y === y) return true;
                return this.player.tail.some((segment) => segment.x === x && segment.y === y);
            }

            handleKeyPress(event) {
                const key = event.key.toLowerCase();
                if (["w", "a", "s", "d"].includes(key)) {
                    this.currentKey = key;
                }
            }

            checkGameOver() {
                // end the game if the player hits a wall or crosses their own tail
                if (
                    this.player.x < 0 ||
                    this.player.x >= this.numSquares ||
                    this.player.y < 0 ||
                    this.player.y >= this.numSquares ||
                    this.player.tail.some((segment) => segment.x === this.player.x && segment.y === this.player.y)
                ) {
                    this.endGame("You hit a wall or crossed your own tail!");
                }
            }

            checkCollisions() {
                for (let i = this.ducks.length - 1; i >= 0; i--) {
                    const duck = this.ducks[i];
                    if (this.player.x === duck.x && this.player.y === duck.y) {
                        this.ducks.splice(i, 1);
                        duck.element.remove();
                        this.score++; // increment score
                        this.spawnDuck();
                        this.updateScore();
                    }
                }
            }

            updateScore() {
                const topBar = document.getElementById("top-bar");
                topBar.innerText = `Score: ${this.score}`;
            }

            startGameLoop() {
                this.gameInterval = setInterval(() => {
                    this.movePlayer();
                    this.checkCollisions();
                }, 250);
            }

            endGame(message) {
                clearInterval(this.gameInterval);
                alert(`${message} Game Over! Final Score: ${this.score}`);
                window.location.reload();
            }
        }

        window.onload = () => {
            new BikeGame();
        };
    </script>
</body>
</html>