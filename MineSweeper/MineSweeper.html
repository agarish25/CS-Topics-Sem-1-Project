<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Duck Minesweeper</title>
  <style>
    /* Duck Minesweeper Styles */

    .minesweeper-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin-top: 20px;
    }

    h1 {
      font-size: 2rem;
      color: #333;
    }

    .timer {
      font-size: 1.2rem;
      margin-bottom: 10px;
      text-align: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      gap: 5px;
      margin: 20px 0;
    }

    .cell {
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 2px solid #ccc;
      background-color: #f9f9f9;
      cursor: pointer;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .cell.revealed {
      background-color: #e0ffe0;
      cursor: default;
    }

    .cell.flagged {
      background-color: #ffefc6;
      cursor: pointer;
    }

    .cell.duck {
      background-color: #ffe0e0;
      color: #ff5050;
    }

    button {
      padding: 10px 20px;
      font-size: 1rem;
      color: #fff;
      background-color: #007bff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:active {
      background-color: #004494;
    }

    .message {
      font-size: 1.5rem;
      color: green;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="root" class="minesweeper-container">
    <h1>Duck Minesweeper</h1>
    <div class="timer">Time: 0 seconds</div>
    <p>Loading game...</p>
  </div>

  <script>
    // Basic implementation for Duck Minesweeper
    class DuckMinesweeper {
      constructor(container) {
        this.container = container;
        this.rows = 10;
        this.cols = 10;
        this.numDucks = 10;
        this.grid = [];
        this.gameOver = false;
        this.startTime = null;
        this.timerInterval = null;
        this.flags = 0;
        this.revealedCells = 0;
        this.init();
      }

      init() {
        this.startTime = Date.now();
        this.timerInterval = setInterval(() => this.updateTimer(), 1000);
        this.generateGrid();
        this.render();
      }

      updateTimer() {
        const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
        this.container.querySelector(".timer").textContent = `Time: ${elapsedTime} seconds`;
      }

      generateGrid() {
        this.grid = Array.from({ length: this.rows }, () =>
          Array.from({ length: this.cols }, () => ({
            revealed: false,
            isDuck: false,
            neighborDucks: 0,
            flagged: false
          }))
        );

        let placedDucks = 0;
        while (placedDucks < this.numDucks) {
          const row = Math.floor(Math.random() * this.rows);
          const col = Math.floor(Math.random() * this.cols);

          if (!this.grid[row][col].isDuck) {
            this.grid[row][col].isDuck = true;
            placedDucks++;

            for (let r = row - 1; r <= row + 1; r++) {
              for (let c = col - 1; c <= col + 1; c++) {
                if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                  this.grid[r][c].neighborDucks++;
                }
              }
            }
          }
        }
      }

      revealCell(row, col) {
        if (this.grid[row][col].revealed || this.grid[row][col].flagged || this.gameOver) return;
        this.grid[row][col].revealed = true;
        this.revealedCells++;

        if (this.grid[row][col].isDuck) {
          this.gameOver = true;
          clearInterval(this.timerInterval);
          alert("You hit a duck! Game Over!");
          this.revealAllDucks();
          return;
        } 

        if (this.grid[row][col].neighborDucks === 0) {
          for (let r = row - 1; r <= row + 1; r++) {
            for (let c = col - 1; c <= col + 1; c++) {
              if (
                r >= 0 &&
                r < this.rows &&
                c >= 0 &&
                c < this.cols &&
                !this.grid[r][c].revealed
              ) {
                this.revealCell(r, c);
              }
            }
          }
        }
        this.checkWin();
        this.render();
      }

      flagCell(row, col) {
        if (this.grid[row][col].revealed || this.gameOver) return;
        this.grid[row][col].flagged = !this.grid[row][col].flagged;
        this.flags += this.grid[row][col].flagged ? 1 : -1;
        this.checkWin();
        this.render();
      }

      revealAllDucks() {
        this.grid.forEach(row => {
          row.forEach(cell => {
            if (cell.isDuck) {
              cell.revealed = true;
            }
          });
        });
        this.render();
      }

      checkWin() {
        const totalCells = this.rows * this.cols;
        const allDucksFlagged = this.grid.every(row =>
          row.every(cell => (cell.isDuck ? cell.flagged : true))
        );

        if (this.revealedCells === totalCells - this.numDucks && allDucksFlagged) {
          this.gameOver = true;
          clearInterval(this.timerInterval);
          const message = document.createElement("div");
          message.className = "message";
          message.textContent = "Congratulations! You won Duck Sweeper!";
          this.container.appendChild(message);
        }
      }

      render() {
        const gridDiv = document.createElement("div");
        gridDiv.className = "grid";

        this.grid.forEach((row, rowIndex) => {
          row.forEach((cell, colIndex) => {
            const cellDiv = document.createElement("div");
            cellDiv.className = `cell ${cell.revealed ? "revealed" : ""} ${cell.flagged ? "flagged" : ""} ${
              cell.isDuck && cell.revealed ? "duck" : ""
            }`;

            if (cell.revealed) {
              cellDiv.textContent = cell.isDuck ? "ðŸ¦†" : cell.neighborDucks || "";
            } else if (cell.flagged) {
              cellDiv.textContent = "ðŸš©";
            }

            cellDiv.onclick = () => this.revealCell(rowIndex, colIndex);
            cellDiv.oncontextmenu = (e) => {
              e.preventDefault();
              this.flagCell(rowIndex, colIndex);
            };

            gridDiv.appendChild(cellDiv);
          });
        });

        const resetButton = document.createElement("button");
        resetButton.textContent = "Restart Game";
        resetButton.onclick = () => {
          clearInterval(this.timerInterval);
          this.gameOver = false;
          this.flags = 0;
          this.revealedCells = 0;
          this.init();
        };

        this.container.innerHTML = "";
        this.container.appendChild(gridDiv);
        this.container.appendChild(resetButton);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      new DuckMinesweeper(document.getElementById("root"));
    });
  </script>
</body>
</html>
